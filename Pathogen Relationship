title: "Pathogen_Relationship"
author: "Syed Shahzaib Ali"
output:
  pdf_document: default
  html_document: default
---
##Objective of the Project

Ths project will explore how genetically similar are gram positive bacteria, gram negative bacteria and acid fast stain bacteria. The hypothesis explored here is that gram bacteria will be much more similar to acid fast stain bacteria than gram positive bacteria as they have a considerbaly tough outer shell thus the reason they are very difficult to treat. A simiar characterisitc shared by Acid-Fast stain bacteria. Furthermore, bacterial sequences for two genes (16S and 23S) have been extracted using NCBI database, which then have been used to calcualte pairwise distances and subjected for construction of phylogenetic trees in order to explore weather these two genes give a different or the same outcome. 

17 bacterial species are explored here. These are: Staphylococcus aueres, Clostridicum Botulinum, E.coli:O157, Yersinia Pestis, Klebsiella pneomniae, Mycobacterium tuberculosis, Nocardia asteroides, Borrelia burgdorferi, Listeria monocytogenes, Pseudomonas aeruginosa, Clostridium tetani, Bacillus anthracis, Helicobacter pylori, Salmonella enterica, egionella pneumophila, Campylobacter jejuni, Streptococcus pneumoniae. 

##Step1: Package Uploading

The first chunk of the code uploads the packages which are required for certain function to operate and give the desired output.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rentrez)
library(ggtree)
library(tidyverse)
library(ape)
library(seqinr)
library(Biostrings)
library(seqRFLP)
library(DECIPHER)
library(muscle)
library(dendextend)
```

##Step2: Obtaining the Sequences

Here the entrez_search function (which belongs to the rentrez package) is applied. This allows for the searching of sequences pertaining to the set of organisms mentioned and store in the object Bacteris_23s. The retmax is set to 200 which means 200 sequences and this is done to allow all sequences from all the organisms to be stored in the object. If a lower number is set than not all sequences will be obtained. The reason being as it does this randomly and does select equal number of sequences for each organism. The use_history function is applied in order to get a large amount of data. If this is not set to TRUE it will give you a error because the data set is too large.  

```{r, include=FALSE}
Bacteria_23s <- entrez_search(db = "nuccore", term = "(Staphylococcus aureus[ORGN] OR Clostridium botulinum[ORGN] OR Escherichia coli O157:H7[ORGN] OR Yersinia pestis[ORGN] OR Klebsiella pneumoniae[ORGN] OR Klebsiella pneumoniae[ORGN] OR Mycobacterium tuberculosis[ORGN] OR Nocardia[ORGN] OR Borrelia burgdorferi[ORGN] OR Listeria monocytogenes[ORGN] OR Pseudomonas aeruginosa[ORGN] OR Clostridium tetani[ORGN] OR Bacillus anthracis[ORGN] OR Helicobacter pylori[ORGN] OR Salmonella enterica[ORGN] OR Legionella pneumophila[ORGN] OR Campylobacter jejuni[ORGN] OR Streptococcus pneumoniae[ORGN] AND 23S  AND biomol_rRNA[PROP]", retmax = 200, use_history = TRUE)
```

##Step3: Creation of Fasta File

The organisms and type of sequences that were asked to be searched using the above function are now retyped as fasta and also allow the organism names to be attached with their pertaining sequences. The sequences were stored in the object Bacteria.23 and then data was subjected to be written in a fasta file on the hard-disk. A necessary for the creation of DNA string set. Finally the fasta file which was saved as 23S.fasta is read as DNA string set.

```{r, include=TRUE}
Bacteria.23 <- entrez_fetch(db = "nuccore", web_history = Bacteria_23s$web_history, rettype = "fasta")
write(Bacteria.23, "23S.fasta", sep = "\n")
rm(Bacteria.23)
Bacteria_23s.string <- readDNAStringSet("23S.fasta", format = "fasta")
class(Bacteria_23s.string)
```


##Step4: Creation of Data Frame. 

In order to edit the names and the sequences, DNA string set must be converted to a dataframe format. Thus the function data.frame is appled. Considering that names obtained from the ncbi database are long and messy they have to be trimmed down to make readable. I have trimmed the accession numbers and all other unneccessary information and have kept the species name. Once the data was re-organized, the unique function was applied to only get the unique names and sequences. 

The filter function is also applied because for some reason even though the species name was specified when obtaining the data from NCBI some species belonging to same Genus were also included in the data set. For example you wll find that in New.23S there are different Mycobacterium species not just Mycobacterium tuberculosis. Thus the reason filtered was applied. Finally, duplicated function was applied to remove the duplicates. Why duplicates when unique is applied? Because even though the name is same the sequence varies slightly and it considers it as a whole a unique data. Now you can view the final data set. 

```{r, include= TRUE}
Data.23S <- data.frame(S_Title = names(Bacteria_23s.string), S_Sequence = paste(Bacteria_23s.string)) 
Data.23S$S_Title <- word(Data.23S$S_Title, 2L, 3L)
New.23S <- Data.23S[, c("S_Title",  "S_Sequence")]
#view(New.23S)
Unique.23S <- unique(New.23S) 
Final.23S <- Unique.23S %>% filter(S_Title %in% c("Mycobacterium tuberculosis", "Staphylococcus aureus", "Klebsiella pneumoniae", "Borrelia burgdorferi", "Listeria monocytogenes", "Nocardia cyriacigeorgica", "Yersinia pestis", "Pseudomonas aeruginosa", "Escherichia coli", "Clostridium botulinum", "Clostridium tetani", "Bacillus anthracis", "Helicobacter pylori", "Salmonella enterica", "Legionella pneumophila", "Campylobacter jejuni", "Streptococcus pneumoniae", "Corynebacterium diphtheria"))
Final.23S <- Final.23S[!duplicated(Final.23S$S_Title),]
rm(Unique.23S, New.23S, Data.23S)
view(Final.23S)
```


##Step5: Exploring Basic Characterisitcs of the Data

nchar counts the nucleotides for all the sequences in the daa set and mean will give the average of length of nucleotides found in the dataset. 

Summary function will reveal the length of shortest nucleotide sequence, mean, median and the length DNA sequence with the most nucleotides in the dataset. 

```{r, include=TRUE}
mean(nchar(Final.23S$S_Sequence))
str_count(paste(Final.23S$S_Sequence, collapse=""), 'N')
summary(nchar(Final.23S$S_Sequence))
```

##Step6A: Removal of N's and Gaps

The sequences are subjected for the removal of N's and gaps and the end and begining of sequence. 

```{r, include=TRUE}
Edited.Final23S <- Final.23S %>% mutate(S_Sequence = str_remove(S_Sequence, "^[-N]+")) %>% mutate(S_Sequence = str_remove(S_Sequence, "^[-N]+$"))
str_count(paste(Edited.Final23S$S_Sequence, collapse=""), 'N')
str_count(paste(Edited.Final23S$S_Sequence, collapse=""), '-')
ggplot(Edited.Final23S) +
  geom_histogram(aes(x = nchar(S_Sequence)), binwidth = 100, color = "plum2", fill = "plum2") +
  labs(x = "Sequence Length (nucleotides)", y = "Number of Sequences", title = " 23S rRNA Sequence Length Distribution") 
summary(nchar(Edited.Final23S$S_Sequence))
class (Edited.Final23S)
```

#Step6B: Exploring the length of each DNa sequence

Here I have created a function len_nuc, that will provide the length of each DNA sequence. This will give a rough idea if the sequences are of equal length and if there are sequences that are too small then they must be removed as it affects alignments. 

```{r, include=TRUE}
len_nuc <- function(filename){
  
  x <- for(variable in filename) {
    
    print(nchar(variable))
    
  }
  
  return(x)
}
len_nuc(Edited.Final23S)
```

#Step7: Conversion of Dataframe to Fasta file

The dataframe is converted to a fasta file called New.fasta and read as DNA string set and stored in the object DNA.23S. Using the lettersFrequency() function the proportion of GC content is calculated for each sequences and a new dataframe is created in order to plot a bargraph of the GC content for each species. 

```{r, include=TRUE}
dataframe2fas(Edited.Final23S, file = "23New.fasta")
DNA.23S <- readDNAStringSet("23New.fasta")
GC.Content.23S <- ((letterFrequency(DNA.23S, letters = c("G"), as.prob = FALSE)) + (letterFrequency(DNA.23S, letters = c("C"), as.prob = FALSE))) / ((letterFrequency(DNA.23S, letters = c("A"), as.prob = FALSE))+ (letterFrequency(DNA.23S, letters = c("T"), as.prob = FALSE)) + (letterFrequency(DNA.23S, letters = c("C"), as.prob = FALSE)) + (letterFrequency(DNA.23S, letters = c("G"), as.prob = FALSE)))
names.1 <- Edited.Final23S$S_Title
GC.data <- data.frame(names.1, GC.Content.23S)
ggplot(GC.data, aes(names.1, G)) + geom_col(show.legend = TRUE) +
  labs(x = "Species Name", y = "GC proportion", title = " 23S rRNA Sequence GC proportion") 
```

#Step8: Alignment of Sequences

Just as another precautinary measure, the remove gaps function is applied to the sequences. The OrientNucleotides function is applied to make sure the sequences Orientation is correct. The muscle package is applied to align the sequences. Finally to make sure the alignment of sequences is the best as it can be the AdjustAlignment function is applied which will apply the gaps in places in order to improve the alignment. If you want to observe the alignment you can remove the "#" to apply the BrowseSeqs function which will show the alignment in your default browser. 

```{r, include=FALSE}
DNA.23S <- OrientNucleotides(DNA.23S, processors = NULL)
DNA232S.alignment <- DNAStringSet(muscle::muscle(DNA.23S, gapopen = -10000), use.names = T)
#BrowseSeqs(DNA232S.alignment)
```

#Step9: Calculation of Pairwise distance

The first step is to get convert the alignment object DNA23S.alignment to "bin" class. It is a necessary step to calculate to apply the dist.DNA function as it the function only accepts class "bin". The function calculates the pairwise distances. The model applied in TN93 which assumes that the rate of trasnversions and transitions are different. The variance is set to false as similarity is considered here not difference. Finally as.matrix option is set TRUE because we want it in the matrix format. As the Idclusters function accepts a matrix object. 

```{r, include=TRUE}
Pairwise.23.1 <- as.DNAbin(DNA232S.alignment)
class(Pairwise.23.1)
DNA23S.Dist.DNA <- dist.dna(Pairwise.23.1, model = "TN93", variance = FALSE, gamma = FALSE, pairwise.deletion = FALSE, base.freq = NULL, as.matrix = TRUE)
class(DNA23S.Dist.DNA)
```

#Step10: Constructon of Phylogenetic trees

The Idclusters function automatically detects the numbers of clusters and by detecting the similarities and creates a list object. Though it is a list object interms of visualization it looks like a dendrogram. For a much more better visualization of tree the ggtree function is applied. However, the ggtree function takes the object phylo. Thus, matrix object DNA23S.Dist.DNA is converted to dist class and subject for allgomerative method hierachail clsutering. The clusters formed are stored in the object "". The object then is converted to phylo object using function as.phylo.hclust. Once the phylo class object is obtained it is inputed into ggtree function to get a proper phylogenetic tree. 

```{r, include=TRUE}
clusters.DNA23 <- IdClusters(DNA23S.Dist.DNA,
                           method = "NJ",
                           cutoff = 0.03,
                           showPlot = TRUE,
                           type = "both",
                           verbose = TRUE)
Dist.23S <- dist(DNA23S.Dist.DNA, method = "euclidean")
S23.Cluster <- hclust(Dist.23S, method = "average")
Phylo.23 <- as.phylo.hclust(S23.Cluster)
ggtree(Phylo.23, mapping = NULL, layout = "rectangular", ) + geom_tiplab(hjust = -0.1, size=3, align = TRUE, linesize = 0.5) + xlim(-5, 10)
```

## Part 2: Analysis of 16S Bacterial Sequences

Same Steps that were applied previously have been applied in this part. Just the data acquisition has been changed from 23S sequences to 26S sequences. Once the data was obtained they written in a fasta file and later converted to DNA string set and then dataframe format. The sequences were subjected to removal of gaps and then for alignment. Futhermore, pairwise distances were calculated which then were used for formation of phylogenetic trees. 

```{r, include=FALSE}
Bacteria_16s <- entrez_search(db = "nuccore", term = "(Staphylococcus aureus[ORGN] OR Clostridium botulinum[ORGN] OR Escherichia coli [ORGN] OR Yersinia pestis[ORGN] OR Klebsiella pneumoniae[ORGN] OR Klebsiella pneumoniae[ORGN] OR Mycobacterium tuberculosis[ORGN] OR Nocardia[ORGN] OR Borrelia burgdorferi[ORGN] OR Listeria monocytogenes[ORGN] OR Pseudomonas aeruginosa[ORGN] OR Clostridium tetani[ORGN] OR Bacillus anthracis[ORGN] OR Helicobacter pylori[ORGN] OR Salmonella enterica[ORGN] OR Legionella pneumophila[ORGN] OR Campylobacter jejuni[ORGN] OR Streptococcus pneumoniae[ORGN] AND 16S  AND biomol_rRNA[PROP]", retmax = 1000, use_history = TRUE)
Bacteria.16 <- entrez_fetch(db = "nuccore", rettype = "fasta", web_history = Bacteria_16s$web_history)
write(Bacteria.16, "16S.fasta", sep = "\n")
Bacteria_16s.string <- readDNAStringSet("16S.fasta", format = "fasta")
Data.16S <- data.frame(S_Title = names(Bacteria_16s.string), S_Sequence = paste(Bacteria_16s.string)) 
Data.16S$S_Title <- word(Data.16S$S_Title, 2L, 3L)
New.16S <- Data.16S[, c("S_Title",  "S_Sequence")]
Unique.16S <- unique(New.16S) 
Final.16S <- Unique.16S %>% filter(S_Title %in% c("Mycobacterium tuberculosis", "Staphylococcus aureus", "Klebsiella pneumoniae", "Borrelia burgdorferi", "Listeria monocytogenes", "Nocardia cyriacigeorgica", "Yersinia pestis", "Pseudomonas aeruginosa", "Escherichia coli", "Clostridium botulinum", "Clostridium tetani", "Bacillus anthracis", "Helicobacter pylori", "Salmonella enterica", "Legionella pneumophila", "Campylobacter jejuni", "Streptococcus pneumoniae", "Corynebacterium diphtheria"))
Final.16S <- Final.16S[!duplicated(Final.16S$S_Title),]
view(Final.16S)
```

```{r, include= TRUE}
mean(nchar(Final.16S$S_Sequence))
summary(nchar(Final.16S$S_Sequence))
len_nuc <- function(filename){
  
  x <- for(variable in Final.16S$S_Sequence) {
    
    print(nchar(variable))
    
  }
  
  return(x)
}
len_nuc(Final.16S$S_Sequence)
median(nchar(Final.16S$S_Sequence))
```

```{r, include=TRUE}
Edited.Final16S <- Final.16S %>% mutate(S_Sequence = str_remove(S_Sequence, "^[-N]+")) %>% mutate(S_Sequence = str_remove(S_Sequence, "^[-N]+$"))
ggplot(Edited.Final16S) +
  geom_histogram(aes(x = nchar(S_Sequence)), binwidth = 4, color = "plum2", fill = "plum2") +
  labs(x = "Sequence Length (nucleotides)", y = "Number of Sequences", title = " 16S rRNA Sequence Length Distribution") 
summary(nchar(Edited.Final16S$S_Sequence))
len_nuc(Edited.Final16S$S_Sequence)
class (Edited.Final16S)
```

```{r, include=FALSE}
dataframe2fas(Edited.Final16S, file = "16New.fasta")
DNA.16S <- readDNAStringSet("16New.fasta")
GC.Content.16S <- ((letterFrequency(DNA.16S, letters = c("G"), as.prob = FALSE)) + (letterFrequency(DNA.16S, letters = c("C"), as.prob = FALSE))) / ((letterFrequency(DNA.16S, letters = c("A"), as.prob = FALSE))+ (letterFrequency(DNA.16S, letters = c("T"), as.prob = FALSE)) + (letterFrequency(DNA.16S, letters = c("C"), as.prob = FALSE)) + (letterFrequency(DNA.16S, letters = c("G"), as.prob = FALSE)))
names.2 <- Edited.Final16S$S_Title
GC.data.1 <- data.frame(names.2, GC.Content.16S)
ggplot(GC.data.1, aes(names.2, G)) + geom_col(show.legend = TRUE) +
  labs(x = "Species Name", y = "GC proportion", title = " 16S rRNA Sequence GC proportion") 
```

```{r, include=FALSE}
DNA.16S <- OrientNucleotides(DNA.16S)
DNA162S.alignment <- DNAStringSet(muscle::muscle(DNA.16S, gapopen = -10000), use.names = T)
```

```{r, include=TRUE}
Pairwise.16.1 <- as.DNAbin(DNA162S.alignment)
DNA16S.Dist.DNA <- dist.dna(Pairwise.16.1, model = "TN93", variance = FALSE, gamma = FALSE, pairwise.deletion = FALSE, base.freq = NULL, as.matrix = TRUE)
class(DNA16S.Dist.DNA)
clusters.DNA16 <- IdClusters(DNA16S.Dist.DNA,
                             method = "NJ",
                             cutoff = 0.03,
                             showPlot = TRUE,
                             type = "both",
                             verbose = TRUE)
```


```{r, include=TRUE}
DNA16.dist <- dist(DNA16S.Dist.DNA, method = "euclidean")
DNA16.hclust <- hclust(DNA16.dist, method = "average")
Phylo.16 <- as.phylo.hclust(DNA16.hclust)
ggtree(Phylo.16, mapping = NULL, layout = "rectangular", ) + geom_tiplab(hjust = -0.1, size=3, align = TRUE, linesize = 1) + xlim(-5, 10)
```

#Step11: Comparison of Phylogentic tree

The first function gives a written report of where the differences lie. The second function gives a visualization of the comparion between the phylogenetic trees. In order for comparison functions to be applied the Clusters.DNA23 and Clusters. DNA16 objects must be converted to class dendorgram. Thus the reason as.dendrogram fucnction is used. 

```{r, include=TRUE}
Dend.23 <- as.dendrogram(clusters.DNA23[[2]])
Dend.16 <- as.dendrogram(clusters.DNA16[[2]])
comparePhylo(Phylo.23, Phylo.16)
dndlist <- dendextend::dendlist(Dend.23, Dend.16)
dendextend::tanglegram(dndlist, fast = TRUE, margin_inner = 12)
